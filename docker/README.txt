DOCKER
======

Source: https://www.youtube.com/watch?v=b0HMimUb4f0

Basics
------

Pull/download an image from an image registry (by defautl: dockerhub)

    docker pull hello-world

Run a container from an image

    docker run hello-world

List all images

    docker image ls

Lists running containers

    docker ps

List all containers including stopped ones

    docker ps -a/--all


Port Mapping
------------

By default containers are isolated from the host network. In order to
interact with, for example, a web server container, we need to publish
the port that it is listening on, so that our host can see it.

    docker run -p/--publish host_port:container_port image


Running in background
---------------------

Detach after start

    docker run -d/--detach image

    * It outputs the container-id of the detached container
    * Containers can also be identified by their name as well.
      * Unless specified (by --name <cntnr-name>), docker generates a
        random name for each new container, e.g.,

        docker run -d --name my-nginx nginx

To see the logs generated by the detached container:

    docker logs <container-name/id>

    * Logs is also available in the GUI: simply click on the desired
      docker container and select the 'Logs' tab

To stop a running container

    docker stop <container-name/id>

    * Containers can be stopped from the GUI: click on the container
      and then click on the stop button.

Stopped containers will still show up in the list of all docker
containers (docker ps -a/--all). To prune (remove all stopped
containers)

    docker container prune

    * When running a container, --rm removes the container when it
      stops

        docker run --rm image


Tags and Digests
----------------

pin by a tag

If a tag is not specified, docker pulls the 'latest' version or runs
the 'latest' version pulled. To pick a specific version

    docker run image:tag

    docker run nginx:1.27

    * Note that tags are mutable: 1.27.0 may bump up to 1.27.1. To
      mitigate that either choose more specific tag (e.g.
      1.27.0-bookworm) or pin the image by its (sha-256) digest. To
      get the digest of the of the image:

        docker image ls --digest

      To get the tag of a specific image from dockerhub, go to 'Tags'
      tab, click on the desired image, and copy the image digest. Once
      you have the digest,

        docker run/pull image@digest

        docker run/pull image:tag@digest

        ** Note that when <digest> is specified, the <tag> is ignored,
        but the tag can be there for humans to tell which version the
        digest refers to.

    ! For production applications prefer pinning by digests not by
    version.


Environmental variables and arguments (Runtime)
-----------------------------------------------

To pass environment variables to container use the -e/--env option to
docker run,

    docker run -e/--env ABC=123 -e DEF=456 image


Slim images, and Alpine images
------------------------------

Python image by default comes with a full featured Debian image. To
fix that for python or any other image, one can use the '-slim'
version of an image which is the bare bone version of that image.

    docker pull python:3.12-slim

For even larger decrease in size look for images that 'alpine' tag in
them.

    docker pull python:alpine

    * NOTE: Look for the differences between slim and alpine versions.
    Notably alpine uses the musl libc whereas slim uses the Debian
    based glibc. Another difference is that slim uses gnu coreutils
    but slim uses busybox utilities.


Debugging running containers
----------------------------

Sometimes it's necessary to go beyond logs (docker logs) and poke
around in the terminal.

GUI: select Containers on the left bar; click on the container; click
on the 'Exec' tab to get the terminal.

CLI: 'exec' allows execution of a process on an already running
     container.

    docker exec -it/--interactive,--tty <container-name/id> <process>

    docker exec -it <id> /bin/bash


Persistence Storage (Volumes, Bind-mounts)
------------------------------------------

Any new container is a fresh and starts with the same file system
every time. Any time written from previous runs are gone.

    docker run python:3.12 \
        python -c 'f="/data.txt";open(f,"a").write("Ran!\n");print(open(f).read())'

    * It will output every time the following

        Ran!

However, many applications, for example, databases, have data that
they want to persist across runs, even to persist across image
changes (e.g., upgrading the database version). It can be achieved
using a "mount".

    docker run -v/--volume mydata/:/data <image> <command/process>

    docker run -rm -v mydata:data/ python:slim \
        python -c 'f="/data/data.txt";open(f,"a").write("Ran!\n");print(open(f).read())'

  * Mount types:
    1. Volumes                PERSISTENT (Persists even after container removal)
    2. Bind mounts            PERSISTENT (Exists as long as host directory exists)
    3. Tempfs mounts          NOT PERSISTENT

  * Persistence comparison
    Volumes                                    | Bind Mounts
    -------------------------------------------+---------------------------------------------------------------
    Newer                                      | Older (but still useful)
    More features                              | Less features
    Managed by docker daemon                   | Mounts host file/dir into container
    Syntax: provide name of the volume in host | Syntax: Provide relative/absolute path in host
        -v mydata:/path/in/container           |     -v ./mydata:/path/in/container (file/dir editable in host)
        or more verbose --mount                |     -v /mydata:/path/in/container

  * Which Mount?
    Volumes                                | Bind Mounts
    ---------------------------------------+--------------------------------------
    Often better in production             | Often convenient in development
    Not dependent on host filesystem       | Quickly share with host
    Easy to share across containers        |    Gives containers access to host
    Can use remote or cloud storage:       |    Consider read-only mount
        AWS EFS                            |        -v ./mydata:/path/in/container
        NFS                                |
        SSHFS                              |
    Container does not need access to host |
    Not convenient to share with host      |


Remark on Volumes:
- You don't need to manually create the volume. Docker will automatically create it
  if it doesn’t exist when you run the container.
- The volume persists even after the container is removed (--rm only removes the
   container, not the volume).
- Data of a volume is usually stored in: /var/lib/docker/volumes/my-workspace/_data/
- To inspect the volume:

    docker volume inspect my-workspace

Note on performance:
- volumes: Optimized for container storage
- bind mounts: Can be slower due to filesystem overhead

Note on protability:
- volumes: Works anywhere Docker runs
- bind mounts: Requires an exact path on the host

Which One Should You Use?
- Use bind mounts if you want real-time access to your files from your host machine (e.g., working on local code).
- Use volumes if you want persistent storage inside Docker, separate from the host file system.

Example:

    # bind mounts
    docker run -it -rm -v $(PWD):/workspace ubuntu

    # docker volumes
    docker volume create my-workspace  # create a named volume
    docker run -it --rm -v my-workspace:/workspace ubuntu

    # list the volumes
    docker volume ls

    # remove a volume
    docker volume rm my-workspace


Ways to Access and Edit Volume Data (if Needed):

    1. Use docker cp to copy files between the host and container:

        docker cp <container_id>:/workspace/somefile.txt ./somefile.txt

    2. Enter the container and edit files directly: This gives you an interactive shell
    inside the container, and you can directly edit files inside /workspace (which maps to
    the volume).

        docker exec -it <container_id> bash

    3. Use docker volume mount (for advanced use cases): You can manually mount the volume
    on the host’s filesystem, but this is less common and not recommended for normal
    workflows.


Custom Images (build your own Dockerfiles)
------------------------------------------



Multistage builds
-----------------

Multiple FROMS
COPY --from=builder



Docker Compose
--------------

Manage/orchestrate multiple image build and container spawns.
Basically solves the problem of starting and stopping containers
manually.

docker-compose.yml in the root of the project

docker compose build
docker compose up
docker compose down (--rm is passed to docker run)
docker compose stop (only stops the container)


Publishing/Pushing images on a registry
-------------------------------

...
